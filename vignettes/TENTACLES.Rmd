---
title: "TENTACLES"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TENTACLES}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Data Loading

```{r setup, warning=FALSE}
library(TENTACLES)

# Load data
data(acc.count, acc.clin)
acc.count <- acc.count[,1:2000]
```

The count table (`acc.count`) should have samples as rows in the row names, and the row names of the clinical table (`acc.clin`) should correspond to the row names from the count data.

## Pre-Processing

Main steps of the preProcess function include:

1.  **Normalization**: $log_2(CPM+1)$ transformation, if `is.normalized = FALSE`

2.  **Low count filter**: removes genes with low expression in a fraction of the population based on `mincpm` and `minfraction` parameters

3.  **Batch correction**: uses comBat for batch correction based on `batch` and `covar.mod` parameters

4.  **Plots**: PCA and PVCA before and after batch correction if `plot = TRUE` and batch correction is performed.

```{r preProcess, fig.align='center', fig.width=7, fig.height=5, warning=FALSE}
# pre-Process data
pp <- preProcess(
  df.count = acc.count, df.clin = acc.clin,
  batch = "patient.gender",
  covar.mod = "patient.primary_pathology.laterality"
)
```

The `preProcess` function returns an object of class `preProcess.obj` that contains the pre-processed data and intermediate results. Specifically, it includes:

-   **raw**: the raw count table of the input data.

-   **processed**: count tables after each pre-processing step, such as normalization and batch correction.

-   **metadata**: the clinical metadata table provided as input.

-   **data.info**: informations about data type and normalization

## Run Classifiers

Main steps of `runClassifiers` function include:

1.  **Filter non-annotated genes**: removes genes non-annotated in GO and KEGG databases, if `filter = TRUE`.

2.  **Models tuning**: splits dataset into `v` resamples, tests a grid of `n` combinations using `tuning.method` on feature selected (`selector.recipes`) expression matrix and select parameters that maximize `metric` for each model

3.  **Fit models**: on the provided pre-processed dataset (contained in `preProcess.obj` or in `...`)

4.  **Variable Importances**: computes variable importances using *vip* and when not supported uses *vi_permute* with `nsim` permutations

5.  **Plots**: generates plots of:

    -   Heatmap of mis-classified samples

    -   Performance plot for each pair of classifier-feature selector implemented

    -   UpSet plot of common genes found

```{r runClassifiers, fig.align='center', fig.width=7, fig.height=5, warning=FALSE}
# Increase max size for parallel processing
options(future.globals.maxSize = 2 * 1024^3)
# Run classifiers
rc <- runClassifiers(pp,
  models = c("bag_mlp", "rand_forest", "mlp", "C5_rules", "logistic"),
  selector.recipes = c("boruta", "roc", "boruta", "boruta", "roc"),
  filter = TRUE, downsample = TRUE
)
```

The function returns an object of class `runClassifiers.obj`, which includes the following components:

-   **data**: Contains the adjusted input data (`adjusted.data`) and the associated `metadata`.

-   **models.info**: Stores detailed information about the models implemented during the process, including the best hyperparameters obtained from tuning. It is possible to access this information by using `rc@models.info`.

-   **model.features**: Includes the variable importance scores calculated for each model.

-   **performances**: Provides the performance metrics for each model, recorded during both the tuning and fitting phases.

## Get Consensus genes

Main steps of `getConsensus` function include:

1.  **Get Consensus**: compute consensus biomarkers based on 3 possible approaches:

    -   Assign values to `n_min` and `exclude` parameters. In this way we can exclude algorithms with poor performances and pick as consensus genes, those that appeared in at least a number of `n_min` algorithms.

    -   Leave as `NULL` these 2 parameters and specify instead `group1` and `meth1` parameters. In this way we can take the `'union'` or the `'intersection'` of the algorithms listed in `group1`.

    -   Leave as `NULL` `n_min` and `exclude` while specifying `group1`, `group2`, `meth1`, `meth2` and `meth_comb` parameters all together. In this way we can take genes based on the `meth1` of `group1`, `meth_comb` with the `meth2` of `group2`. e.g. take the union (`meth1 = "union"`) of genes in `group1`, the union (`meth2 = "union"`) of genes in `group2` and pick the intersection (`meth_comb = "intersect"`) of these two groups.

2.  **Test Consensus (Plots)**: visual outputs and summaries for PCA, AUROC analysis, heatmap visualization, and testing using a Multi-Layer Perceptron (MLP) model.

```{r getConsensus, fig.align='center', fig.width=7, fig.height=5, warning=FALSE}
# Get and test consensus
gc <- getConsensus(rc, n.min = 3)
```

The function returns a list containing three objects:

-   **consensusGenes**: A vector listing the consensus biomarkers identified.

-   **dataFrame**: A binary data frame indicating the presence (`1`) or absence (`0`) of each gene across the implemented models.

-   **inputParams**: A list of the input parameters provided to the function.Validate Consensus genes

## Test Consensus genes

The `testConsensus` function evaluates a list of consensus genes (`gene.list`) using a series of analyses to assess their performance and relevance in classifying samples in the provided (pre-processed) `df.count`. It provides visual outputs and summaries for Principal Component Analysis (PCA), AUROC analysis, heatmap visualization, and validation using a Multi-Layer Perceptron (MLP) model.

```{r, message=FALSE, fig.align='center', fig.width=7, fig.height=5, warning=FALSE}
# Import NEW data
count_table <- as.data.frame((rc@data$adjusted.data))
gene_list <- gc$consensusGenes
labels <- as.factor(rc@data$metadata$class)
# test consensus on an external dataset
testConsensus(df.count = count_table, gene.list = gene_list, class = labels)
```

The function performs the following steps, generating visualizations for each:

1.  **Principal Component Analysis (PCA)**: Examines how well the consensus genes separate the classes in a PCA plot.

2.  **AUROC Analysis**: Evaluates the ability of the consensus genes to classify samples, producing an AUROC plot.

3.  **Heatmap Analysis**: Creates a heatmap showing hierarchical clustering of samples based on consensus gene expression.

4.  **Validation with MLP Model**: Fits and visualizes a Multi-Layer Perceptron model to validate the classification performance of the consensus genes.

## Validate Consensus genes

Main steps of `valConsensus` include:

1.  **Gene combinations**: given a `gene.list`, it computes all possible combinations of variable length of genes

2.  **Unsupervised Clustering**: it computes for each combination of genes, 6 clustering methods on the `df.count` provided: 

    -   k-Means

    -   Gaussian Mixture Model (GMM)

    -   Hierarchical Clustering (HC)

    -   PCA followed by k-Means

    -   t-SNE followed by k-Means

    -   UMAP followed by k-Means

3.  **Top combinations**: it selects the best `N` combinations of genes that maximize the mean of `metric` across the 6 clustering methods

4.  **Plots**: for the top `N` combinations it plots performances (Accuracy, Precision, Recall, F-Score) of the 6 methods and the AUROC heatmap

```{r validation, message=FALSE, fig.align='center', fig.width=7, fig.height=5, warning=FALSE}
# Import NEW data
count_table <- as.data.frame((rc@data$adjusted.data))

gene_list <- gc$consensusGenes[1:7]
labels <- as.factor(rc@data$metadata$class)

# Validation
vc <- valConsensus(
  df.count = count_table, gene.list = gene_list,
  class = labels, N = 10, metric = "FScore"
)
```

The function returns a list containing two elements:

-   **allResults**: A list of results for each gene combination, with details provided for each of the six implemented clustering algorithms. For each algorithm, it includes the predicted clustering labels and the associated performance metrics.

-   **topCombinations**: A data frame summarizing the performance metrics of the top `N` gene combinations, ranked based on their mean `metric` values.
